Mestre: 10152 COM9
Escravo: 10142 COM6

_________________________________________________________________________
Calibração sensor de corrente:

Primeira calibração:
    8 voltas:
    vMax = 2.80425     -> 16,4 A
    vMin = 1.736812     -> -16,4 A
    vMean = 2.270531    -> 0 A

    Variação vMax - vMean = 0,533V    -> 16,4A
    Indica que a cada 1V -> 30,769A

    Leitura do multímetro:
    11,6 Arms -> 16,4 A


Segunda calibração peo EXCEL com 5 voltas:
            LEITURA	        real	        Leitura RMS pelo Amperímetro 
    max	    2,604563	    4,596194078	    3,25
    min	    2,455312	    -4,596194078	
    media	2,529166073	    0	

    equação definida:
                        Real       =   61,588*Leitura    - 155,8
                        Real       =   a*Leitura   + b



_________________________________________________________________________
Calibração sensor de Tensão:

Primeira calibração:
    vMax = 3.699938     -> 304,763 V
    vMin = 1.297875     -> -304,763 V
    vMean = 2.498906    -> 0 V

    Variação vMax - vMean = 1,201032V    -> 304,763 V
    Indica que a cada 1V ->  253,751 V

    Leitura do multímetro:
    215,5 Vrms -> 304,763 V

Segunda calibração pelo EXCEL:
    calibração do valor instantaneo:
            LEITURA	        real	        Leitura RMS do multímetro
    max	    3,684375	    294,8635278	    208,5
    min	    1,358438	    -294,8635278	
    media	2,518408167	    0	

    equação definida:  Real = 253,54*Leitura - 639,03     R² = 1
                        Real = a*Leitura - b

Equação para implementação de autocalibração:
    vpico = meterRMS*sqrt(2);
    a = (2*vpico)/(LeituraMax - LeituraMin);
    b = -(a*LeituraMedia);

OBS: Com essas calibrações, obtive o erro de -0.05Arms do lido para o Real e -5Vrms
{"V":[[-9035,47880,-63221],[0,0,0],[0,0,0]],"I":[[1331.170044,-3398.409912,0],[0,0,0],[0,0,0]]}
Tarefa de casa
_________________________________________________________________________

comunicação com o esp32 por via webservice para os dados de configuração



links importantes:
https://github.com/tobozo/YAMLDuino
https://blog.eletrogate.com/spiffs-armazenamento-de-arquivos-do-esp32/
https://randomnerdtutorials.com/install-esp32-filesystem-uploader-arduino-ide/
https://blog.r0b.io/post/deploying-esp32-with-spiffs-using-github-actions/
https://github.com/Nabilphysics/json-data-save-to-spiffs-esp32/blob/main/json-data-save-to-spiffs-esp32/json-data-save-to-spiffs-esp32.ino
https://kongduino.wordpress.com/2018/04/30/preferences-spiffs-and-json/

__________________________________________________________________________________
Informações para a construção da board:
- resistor de pullup no sda e slc do ads retira erro de leitura;
- resistor para offset do sensor de corrente;
- amplificador acionado para leitura dos sensore de corrente quando em calibração?





_________________________________________________________________________
A alocação de memória do DynamicJsonDocument foi basedo no seguinte:
Para calcular a melhor alocação de memória para um `DynamicJsonDocument` que vai manipular esse JSON, é necessário considerar o tamanho e a estrutura do JSON. O `DynamicJsonDocument` precisa ser capaz de armazenar os objetos, arrays e os valores numéricos.

O JSON terá a seguinte estrutura:

{
  "V": [
    {"a": 1, "b": 0},
    {"a": 1, "b": 0},
    {"a": 1, "b": 0}
  ],
  "I": [
    {"a": 1, "b": 0},
    {"a": 1, "b": 0},
    {"a": 1, "b": 0}
  ]
}


### Considerações para o cálculo:
- Existem dois objetos principais (`V` e `I`), que contêm arrays.
- Cada array tem 3 objetos, cada um com dois campos (`a` e `b`), e cada campo contém números de ponto flutuante.

### Estimativa de memória

A biblioteca `ArduinoJson` fornece uma maneira de estimar a quantidade de memória necessária com a função `JSON_OBJECT_SIZE()` e `JSON_ARRAY_SIZE()`.

Neste caso:
- O JSON contém dois objetos principais (`V` e `I`), então precisamos de `JSON_OBJECT_SIZE(2)`.
- Cada um desses objetos contém um array de 3 objetos, então precisamos de `JSON_ARRAY_SIZE(3)`.
- Cada um desses objetos dentro do array contém dois campos (`a` e `b`), então precisamos de `JSON_OBJECT_SIZE(2)` para cada objeto no array.

### Cálculo detalhado

A memória necessária é a soma do tamanho dos objetos principais, os arrays, e os objetos dentro dos arrays. Com base nisso:

- `JSON_OBJECT_SIZE(2)` para os objetos principais (`V` e `I`).
- `JSON_ARRAY_SIZE(3)` para cada array contendo 3 objetos.
- `3 * JSON_OBJECT_SIZE(2)` para os 3 objetos dentro do array, cada um com dois pares `a` e `b`.

O total será:

const size_t capacity = JSON_OBJECT_SIZE(2) + 2 * JSON_ARRAY_SIZE(3) + 6 * JSON_OBJECT_SIZE(2);

A função `JSON_OBJECT_SIZE(2)` retorna a quantidade de bytes necessária para armazenar um objeto com 2 pares chave/valor, e `JSON_ARRAY_SIZE(3)` retorna o tamanho de um array com 3 elementos.

### Cálculo exato com o valor:

- `JSON_OBJECT_SIZE(2)` para "V" e "I" = 2 * 32 bytes (estimado).
- `JSON_ARRAY_SIZE(3)` para os arrays = 2 * 48 bytes (estimado).
- `3 * JSON_OBJECT_SIZE(2)` para os objetos dentro de "V" e "I" = 6 * 32 bytes (estimado).

Somando, temos:

const size_t capacity = 32 + 32 + 48 + 48 + (6 * 32);  // Total: 384 bytes


Portanto, o valor recomendado para o `DynamicJsonDocument` seria de **384 bytes**.

### Exemplo de código:

DynamicJsonDocument doc(384);


Esse valor garante que seu JSON será armazenado adequadamente no `DynamicJsonDocument` sem estourar a memória alocada.





_______________________________________________________________________________________________________________
TODO:


MESH:
sempre que enviar os pacotes pelo Mesh mostrar valor RSSI do Mestre, distância entre o escravo e mestre, e SRN

buscar o timer na spiffs ou usar o default

BROKER WIFI:
validade de envio dos pacotes, ou falha

inicialização mostrar IP, SSID, o broker, informações do broker aws, tamanho de pacote, 


corrigir calibração
 